## Основы ООП

Основная идея ООП заключается в том, что мы используем обьекты для отображения реального мира в программе и/или упрощения доступа к функциям, методам, которые в противном случае было бы трудно использовать.
Они могут содержать данные и информацию о том, что вы пытаетесь смоделировать и возможности и поведения этих обьектов. Эти обьекты обычно называются классами `class`, они содержат в себе логику и поведения класса, создают свой екземпляр `instance`, аосолютно обособленный, путем вызова функции-конструктора.
В ООП можно создавать новые классы на основе других - `наследование` классов, через слово `extends`, класс может наследовать только 1класс, но эта цпочка не ограничена в глубину (что может привести к сильной связанности классов и плохо переиспользуемому коду).

      В TS есть возможность создать интерфейс класса или abstract class, с описанием его методов

- method - функция внутри класса
- extends - используется для определениянаследования
- super - метод, который устанавливает свойства наследования за счет вызова родительского конструктора
- get - вернет значение
- set - установит значение
- new - создаст екземпляр класса
- private - показывает, что метод или переменная приватны (только внутри класса) ts
- static - показывает, что метод или свойство доступны до вызова конструктора (не имеет this)

JS использует специальные функции, называемые конструкторами для определенияобьектов и их свойств (Любая функция вызванная через `new` - является конструктором. В ООП используется прототипное наследование, `функция-конструктор` - указывается в свойство `__proto__` - для своего екземпляра.

      children.__proto__ === Parent.prototype
      Parent.__proto__ === Function.prototype

      Стоит заметить, что `prototype` - это самостоятельный обьект, есть только у классов и функций,
      исключая `стрелочную функцию`.

```js
function Person(age, name) {
  this.age = age;
  this.name = name;
}

Person.prototype.getInfo = function () {
  return this;
};

const john = new Person(22, "John");
```

У класса есть приватные методы, статические, публичные, get, set. `get, set` - обычно используют, чо бы достать или переопределить приватное свойство.

```ts
class Person {
  constructor(age, name) {
    this.age = age;
    this.name = name;
  }

  static foo() {
    // нет this
    return 12;
  }

  get info() {
    return this;
  }

  set name(newName) {
    console.log("set name", newName);
  }

  public showInfo() {
    return this.create();
  }

  private create() {
    return {
      age: thi.age,
      name: thi.name,
    };
  }
}
```

## Теория

принципы ООП - SOLID

- S single responsebility (принцип единой ответственности)
- O open-closed (принцип открытости-закрытости)
- L liskov substition (принцип подсановки Барбары Лисков)
- I interface segregation (принцип разделение интерфейса)
- D dependency inversion (принцип инверсии зависимостей)

## SRP

Данный принцип указывает на то, что обьект должен иметь только ОДНУ обязанность и эта обязанность должна быть полносью инкапсулированна. Все методы класса должны быть направлены исключительно на обеспечение этой обязанности.
Следование принципу заключается в декомпозиции больших классов на более мелкие, но с конкретной реализацией задачи. Такие классы легче модифицировть и при этом не бояться, что они поломают что то из вне.
Но этот принцип можно применить и для того, чтобы вынести повторяющуюся логику в свой класс и переиспользовать ее в других. Наиболее яркий антипатерн - "Божественный обьект", разработчики выносят туда всю логику и он может разрастись до огромных размеров, поддерживать его будет очень трудно. Но есть случаи, когда этот принцип можно нарушить - `ActiveRecord`, это говорит о том, что его нужно использовать с умом и нарушение его может быть вполне логичным.

## Open-closed

Данный принцип декларирует, что сущности (классы, модули) - могут быть расширяемы, но они закрыты для модификаций. Тоесть они могут менять свое поведения посредством расширения, а не имзенения своего кода (например с помощью декораторов или же наследования).
Открытость для расширения - это возможность добавить новый функционал, не озменив исходный класс. Данная спецификация указывает, что интерфейс для наследника можно изменить и он не обязан использовать строго исходный.

      Полиморфный принцип - подразумевает использование от абстрактного интерфейса,
      он не может быть изменен, но новые могут от него наследоваться и они должны как минимум
      реализовывать этот интерфейс.

## liskov substition

Данный принцип декларирует, что класс - наследник, использующий базовый тип (родителя), должен использовать подтип базового класса, не зная об этом. Тоесть создаваемые наследники должны корректно реализовывать инерфейс родительского класса, его поведение. Проще - если базовый тип реализовывает поведение - его наследники должны соответствовать контракту интерфейса базового класса.
Наследник класса - должен дополнить родителя, но не заменить, тоесть везде, где используется базовый класс, можно взять наследника и не должно быть ошибок. Этот принцип предполагает, что любой созданный класс-наследник использует ранее реализованные модули и может иметь новое поведение.

## interface segregation

Принцип декларирует, что клиентский класс не должен зависеть от методов интерфейса, которые он не использует. Данные принцип перекликается с SRP - интерфейс не должен быть перегружен, что хорошо для поддержания класса и его модификации. Если интерфейс громоздкий, есть смысл его декомпозиции на более мелкие.

## dependency inversion

Принцип декларирует, что Абстрактный класс не должен зависить от реализации методов наследника, модули верхних уровней не зависят от нижних, но нижние должны зависить от верхних. Этот принцип заставляет реализовывать высокоуровневые абстракции, без привязки к конкретным наследникам, тоесть этот класс может содержать методы, а наследники их реализацию. Этот подход упростит следование принципу подстановки, та как любой класс, наследованный от такой абстракции может быть легко заменен таким же классом. Например сохранение файлов на облаке и на диске, родитель может содержать абстрактую логику, а наследники конкретную реализацию и эти классы легко подставить друг вместо друга или использовать вместе.
